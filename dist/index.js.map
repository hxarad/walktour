{"mappings":"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","sources":["src/index.ts","src/components/Walktour.tsx","src/components/Mask.tsx","src/utils/dom.ts","src/utils/constants.ts","src/utils/positioning.ts","src/utils/offset.ts","src/utils/viewport.ts","src/components/Tooltip.tsx","src/defaultstyles.ts","src/utils/scroll.ts","src/utils/tour.ts"],"sourcesContent":["import { Walktour } from './components/Walktour';\nimport { Mask } from './components/Mask';\nimport { CardinalOrientation } from './utils/positioning';\n\nexport { Walktour };\nexport { Mask };\n\nexport type { Step, WalktourProps, WalktourOptions, WalktourLogic } from './components/Walktour';\nexport type { MaskOptions } from './components/Mask';\nexport { CardinalOrientation };\nexport type { Coords, Dims, ElementInfo } from './utils/dom';\n","import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { Mask, MaskOptions } from './Mask';\nimport { Tooltip } from './Tooltip';\nimport { CardinalOrientation, OrientationCoords, getTargetPosition, getTooltipPosition } from '../utils/positioning';\nimport { Coords, getNearestScrollAncestor, getValidPortalRoot, Dims, getElementDims, getTargetInfo } from '../utils/dom';\nimport { scrollToDestination } from '../utils/scroll';\nimport { centerViewportAroundElements } from '../utils/offset';\nimport { debounce, getIdString, shouldUpdate, setFocusTrap, setTargetWatcher, setTourUpdateListener, shouldScroll, setNextOnTargetClick } from '../utils/tour';\n\nexport interface WalktourLogic {\n  next: (fromTarget?: boolean) => void;\n  prev: () => void;\n  close: (reset?: boolean) => void;\n  goToStep: (stepNumber: number) => void;\n  stepContent: Step;\n  stepIndex: number;\n  allSteps: Step[];\n  tooltipPosition: OrientationCoords;\n}\n\nexport interface WalktourOptions {\n  disableMaskInteraction?: boolean;\n  disableCloseOnClick?: boolean;\n  orientationPreferences?: CardinalOrientation[];\n  maskPadding?: number;\n  maskRadius?: number;\n  maskFillColor?: string;\n  maskOpacity?: number;\n  maskBackdropFilter?: string;\n  tooltipSeparation?: number;\n  transition?: string;\n  customTitleRenderer?: (title?: string, tourLogic?: WalktourLogic) => JSX.Element;\n  customDescriptionRenderer?: (description: string, tourLogic?: WalktourLogic) => JSX.Element;\n  customFooterRenderer?: (tourLogic?: WalktourLogic) => JSX.Element;\n  customTooltipRenderer?: (tourLogic?: WalktourLogic) => JSX.Element;\n  customNextFunc?: (tourLogic: WalktourLogic, fromTarget?: boolean) => void;\n  customPrevFunc?: (tourLogic: WalktourLogic) => void;\n  customCloseFunc?: (tourLogic: WalktourLogic) => void;\n  prevLabel?: string;\n  nextLabel?: string;\n  closeLabel?: string;\n  disableNext?: boolean;\n  disablePrev?: boolean;\n  disableClose?: boolean;\n  disableAutoScroll?: boolean;\n  getPositionFromCandidates?: (candidates: OrientationCoords[]) => OrientationCoords;\n  movingTarget?: boolean;\n  updateInterval?: number;\n  renderTolerance?: number;\n  disableMask?: boolean;\n  renderMask?: (maskOptions: MaskOptions) => JSX.Element;\n  disableSmoothScroll?: boolean;\n  allowForeignTarget?: boolean;\n  nextOnTargetClick?: boolean;\n  validateNextOnTargetClick?: () => Promise<boolean>;\n}\n\nexport interface Step extends WalktourOptions {\n  selector: string;\n  title?: string;\n  description: string;\n}\n\nexport interface WalktourProps extends WalktourOptions {\n  steps: Step[];\n  initialStepIndex?: number;\n  zIndex?: number;\n  rootSelector?: string;\n  identifier?: string;\n  setUpdateListener?: (update: () => void) => void;\n  removeUpdateListener?: (update: () => void) => void;\n  disableListeners?: boolean;\n  isOpen?: boolean;\n  debug?: boolean;\n}\n\nconst walktourDefaultProps: Partial<WalktourProps> = {\n  maskPadding: 5,\n  maskRadius: 0,\n  maskFillColor: 'black',\n  maskOpacity: 0.3,\n  tooltipSeparation: 10,\n  transition: 'top 300ms ease, left 300ms ease',\n  disableMaskInteraction: false,\n  disableCloseOnClick: false,\n  zIndex: 9999,\n  renderTolerance: 2,\n  updateInterval: 500\n}\n\nconst basePortalString: string = 'walktour-portal';\nconst baseMaskString: string = 'walktour-mask';\nconst baseTooltipContainerString: string = 'walktour-tooltip-container';\n\nexport const Walktour = (props: WalktourProps) => {\n\n  const {\n    steps,\n    initialStepIndex,\n    isOpen\n  } = props;\n\n  const controlled = isOpen !== undefined;\n  const [isOpenState, setIsOpenState] = React.useState<boolean>(isOpen == undefined);\n  const [target, setTarget] = React.useState<HTMLElement>(undefined);\n  const [tooltipPosition, setTooltipPosition] = React.useState<OrientationCoords>(undefined);\n  const [currentStepIndex, setCurrentStepIndex] = React.useState<number>(initialStepIndex || 0);\n  const [tourRoot, setTourRoot] = React.useState<Element>(undefined);\n\n  const cleanupRefs = React.useRef<Array<() => void>>([]);\n  const tooltip = React.useRef<HTMLElement>(undefined);\n  const portal = React.useRef<HTMLElement>(undefined);\n  const targetPosition = React.useRef<Coords>(undefined);\n  const targetSize = React.useRef<Dims>(undefined);\n\n  const currentStepContent: Step = steps[currentStepIndex];\n  const tourOpen: boolean = controlled ? isOpen : isOpenState;\n\n  const options: WalktourOptions & WalktourProps & Step = {\n    ...walktourDefaultProps,\n    ...props,\n    ...currentStepContent\n  }\n\n  const {\n    selector,\n    maskPadding,\n    maskRadius,\n    maskFillColor,\n    maskOpacity,\n    maskBackdropFilter,\n    disableMaskInteraction,\n    disableCloseOnClick,\n    tooltipSeparation,\n    transition,\n    orientationPreferences,\n    customTooltipRenderer,\n    zIndex,\n    rootSelector,\n    customNextFunc,\n    customPrevFunc,\n    customCloseFunc,\n    disableClose,\n    disableNext,\n    disablePrev,\n    disableAutoScroll,\n    identifier,\n    getPositionFromCandidates,\n    movingTarget,\n    renderTolerance,\n    updateInterval,\n    disableMask,\n    setUpdateListener,\n    removeUpdateListener,\n    disableListeners,\n    disableSmoothScroll,\n    debug,\n    allowForeignTarget,\n    nextOnTargetClick,\n    validateNextOnTargetClick,\n    renderMask\n  } = options;\n\n  React.useEffect(() => {\n    return cleanup;\n  }, []);\n\n  // set/reset the tour root \n  React.useEffect(() => {\n    let root: Element;\n    if (rootSelector) {\n      root = document.querySelector(rootSelector);\n    }\n    if (!root) {\n      root = getNearestScrollAncestor(portal.current);\n    }\n\n    if (tourOpen !== false && root !== tourRoot) {\n      setTourRoot(root);\n    }\n  }, [rootSelector, portal.current, tourOpen])\n\n  // update tour when step changes\n  React.useEffect(() => {\n    if (debug) {\n      console.log(`walktour debug (${identifier ? `${identifier}, ` : \"\"}${currentStepIndex}):`, {\n        \"options:\": options,\n        \"tour logic:\": tourLogic,\n        \"previous state/vars:\": {\n          isOpenState,\n          tourRoot,\n          target,\n          tooltipPosition,\n          targetPosition,\n          currentStepIndex,\n          targetSize,\n        }\n      })\n    }\n    if (tooltip.current && tourOpen) {\n      tooltip.current.focus();\n      updateTour();\n    } else {\n      cleanup();\n    }\n  }, [currentStepIndex, currentStepContent, tourOpen, tourRoot, tooltip.current])\n  \n  // update tooltip and target position in state\n  const updateTour = () => {\n    cleanup();\n    const root: Element = tourRoot;\n    const tooltipContainer: HTMLElement = tooltip.current;\n\n    if (!root || !tooltipContainer) {\n      setTarget(null);\n      setTooltipPosition(null);\n      targetPosition.current = null;\n      targetSize.current = null;\n      return;\n    }\n\n    const targetScope: Element | Document = allowForeignTarget ? document : root;\n    const getTarget = (): HTMLElement => targetScope.querySelector(selector);\n    const currentTarget: HTMLElement = getTarget();\n    const currentTargetPosition: Coords = getTargetPosition(root, currentTarget);\n    const currentTargetDims: Dims = getElementDims(currentTarget);\n    const smartPadding: number = disableMask ? 0 : maskPadding;\n    \n    const tooltipPosition: OrientationCoords = getTooltipPosition({\n      target: currentTarget,\n      tooltip: tooltipContainer,\n      padding: smartPadding,\n      tooltipSeparation,\n      orientationPreferences,\n      root,\n      getPositionFromCandidates,\n      disableAutoScroll,\n      allowForeignTarget,\n      selector\n    });\n\n    setTarget(currentTarget);\n    setTooltipPosition(tooltipPosition);\n    targetPosition.current = currentTargetPosition;\n    targetSize.current = currentTargetDims;\n\n    //focus trap subroutine\n    const cleanupFocusTrap = setFocusTrap(tooltipContainer, currentTarget, disableMaskInteraction);\n    cleanupRefs.current.push(cleanupFocusTrap);\n\n    if (shouldScroll({\n      disableAutoScroll,\n      allowForeignTarget,\n      selector,\n      root,\n      target: currentTarget,\n      tooltip: tooltipContainer,\n      tooltipPosition: tooltipPosition.coords\n    })) {\n      scrollToDestination(root, centerViewportAroundElements(root, tooltipContainer, currentTarget, tooltipPosition.coords, currentTargetPosition), disableSmoothScroll)\n    }\n\n    if (!disableListeners) {\n      const conditionalUpdate = () => {\n        const availableTarget = getTarget();\n\n        if (shouldUpdate({\n          root,\n          tooltipPosition: tooltipPosition.coords,\n          tooltip: tooltipContainer,\n          target: availableTarget,\n          disableAutoScroll,\n          rerenderTolerance: renderTolerance,\n          targetCoords: targetPosition.current,\n          targetDims: targetSize.current,\n          allowForeignTarget,\n          selector,\n          getPositionFromCandidates,\n          orientationPreferences, \n          padding: smartPadding, \n          tooltipSeparation\n        })) {\n          updateTour();\n        }\n      }\n\n      const cleanupUpdateListener = setTourUpdateListener({ update: debounce(conditionalUpdate), customSetListener: setUpdateListener, customRemoveListener: removeUpdateListener });\n      cleanupRefs.current.push(cleanupUpdateListener)\n\n      // if the user requests a watcher and there's supposed to be a target\n      if (movingTarget && (currentTarget || selector)) {\n        const cleanupWatcher = setTargetWatcher(conditionalUpdate, updateInterval)\n        cleanupRefs.current.push(cleanupWatcher);\n      }\n\n      if (nextOnTargetClick && currentTarget) {\n        const cleanupTargetTether = setNextOnTargetClick(currentTarget, tourLogic.next, validateNextOnTargetClick)\n        cleanupRefs.current.push(cleanupTargetTether);\n      }\n    }\n  }\n\n  const goToStep = (stepIndex: number) => {\n    if (stepIndex >= steps.length || stepIndex < 0) {\n      return;\n    }\n    setCurrentStepIndex(stepIndex);\n  }\n\n  const cleanup = () => {\n    cleanupRefs.current.forEach(f => f());\n    cleanupRefs.current = [];\n  }\n\n  const closeTour = (reset?: boolean) => {\n    reset && goToStep(0);\n    !controlled && setIsOpenState(false);\n    cleanup();\n    target && target.focus(); // return focus to last target when closed\n  }\n\n  const baseLogic: WalktourLogic = {\n    next: () => goToStep(currentStepIndex + 1),\n    prev: () => goToStep(currentStepIndex - 1),\n    close: (reset?: boolean) => closeTour(reset),\n    goToStep: goToStep,\n    stepContent: { ...options }, //pass options in as well to expose any defaults that aren't specified\n    stepIndex: currentStepIndex,\n    allSteps: steps,\n    tooltipPosition\n  };\n\n  const tourLogic: WalktourLogic = {\n    ...baseLogic,\n    ...customNextFunc && { next: (fromTarget?: boolean) => customNextFunc(baseLogic, fromTarget) },\n    ...customPrevFunc && { prev: () => customPrevFunc(baseLogic) },\n    ...customCloseFunc && { close: () => customCloseFunc(baseLogic) }\n  };\n\n  const keyPressHandler = (event: React.KeyboardEvent) => {\n    switch (event.key) {\n      case \"Escape\":\n        event.preventDefault();\n        if (!disableClose) {\n          tourLogic.close();\n        }\n        break;\n      case \"ArrowRight\":\n        event.preventDefault();\n        if (!disableNext) {\n          tourLogic.next()\n        }\n        break;\n      case \"ArrowLeft\":\n        event.preventDefault();\n        if (!disablePrev) {\n          tourLogic.prev();\n        }\n        break;\n    }\n  }\n\n  //don't render if the tour is hidden or if there's no step data\n  if (!tourOpen || !currentStepContent) {\n    return null;\n  };\n\n  const portalStyle: React.CSSProperties = {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    zIndex: zIndex,\n    visibility: tooltipPosition ? 'visible' : 'hidden',\n    pointerEvents: \"none\"\n  }\n\n  const tooltipContainerStyle: React.CSSProperties = {\n    position: 'absolute',\n    top: tooltipPosition?.coords?.y,\n    left: tooltipPosition?.coords?.x,\n    transition: transition,\n    pointerEvents: 'auto'\n  }\n\n  const MaskTag = renderMask ? renderMask : Mask;\n\n  // render mask, tooltip, and their shared \"portal\" container\n  const render = () => (\n    <div\n      ref={ref => portal.current = ref}\n      id={getIdString(basePortalString, identifier)}\n      style={portalStyle}\n    >\n      {tourRoot &&\n        <>\n          {!disableMask &&\n            <MaskTag\n              maskId={getIdString(baseMaskString, identifier)}\n              targetInfo={getTargetInfo(tourRoot, target)}\n              disableMaskInteraction={disableMaskInteraction}\n              disableCloseOnClick={disableCloseOnClick}\n              fillColor={maskFillColor}\n              maskOpacity={maskOpacity}\n              maskBackdropFilter={maskBackdropFilter}\n              padding={maskPadding}\n              radius={maskRadius}\n              tourRoot={tourRoot}\n              close={tourLogic.close}\n            />\n          }\n\n          <div\n            ref={ref => tooltip.current = ref}\n            id={getIdString(baseTooltipContainerString, identifier)}\n            style={tooltipContainerStyle}\n            onKeyDown={keyPressHandler}\n            tabIndex={0}\n          >\n            {customTooltipRenderer\n              ? customTooltipRenderer(tourLogic)\n              : <Tooltip\n                {...tourLogic}\n              />\n            }\n          </div>\n        </>\n      }\n    </div>);\n\n  // on first render, put everything in its normal context.\n  // after first render (once we've determined the tour root) spawn a portal there for rendering.\n  if (tourRoot) {\n    return ReactDOM.createPortal(render(), getValidPortalRoot(tourRoot));\n  } else {\n    return render();\n  }\n}\n","import * as React from 'react';\nimport { Coords, Dims, ElementInfo, isDefaultScrollingElement } from '../utils/dom';\nimport { getViewportScrollDims, getViewportDims } from '../utils/viewport';\n\nexport interface MaskOptions {\n  targetInfo?: ElementInfo;\n  padding: number;\n  radius: number;\n  close: () => void;\n  tourRoot: Element;\n  fillColor?: string;\n  maskOpacity?: number;\n  maskBackdropFilter?: string;\n  disableMaskInteraction?: boolean;\n  disableCloseOnClick?: boolean;\n  maskId: string;\n}\n\nexport function Mask(props: MaskOptions): JSX.Element {\n  const {\n    targetInfo,\n    disableMaskInteraction,\n    padding,\n    radius,\n    tourRoot,\n    close,\n    disableCloseOnClick,\n    maskId,\n    fillColor,\n    maskOpacity,\n    maskBackdropFilter\n  } = props;\n  const {width: containerWidth, height: containerHeight} = isDefaultScrollingElement(tourRoot)\n    ? getViewportDims(tourRoot) // avoid growing the document by using the viewport when masking the main scroll container\n    : getViewportScrollDims(tourRoot);\n  console.log('viewport scroll dims', containerWidth,',', containerHeight);\n  const pathId = `clip-path-${maskId}`;\n\n  const getCutoutPath = (target?: {coords: Coords, dims: Dims}): string => {\n    if (!target) {\n      return '';\n    }\n\n    const {\n      dims,\n      coords\n    } = target;\n\n    const cutoutTop: number = coords.y - padding;\n    const cutoutLeft: number = coords.x - padding;\n    const cutoutRight: number = coords.x + dims.width + padding;\n    const cutoutBottom: number = coords.y + dims.height + padding;\n\n    if (radius > 0) {\n      return `M 0, 0\n              L 0, ${containerHeight}\n              L ${cutoutLeft}, ${containerHeight}\n              L ${cutoutLeft}, ${cutoutTop + radius}\n              Q ${cutoutLeft}, ${cutoutTop}, ${cutoutLeft + radius}, ${cutoutTop}\n              L ${cutoutRight - radius}, ${cutoutTop}\n              Q ${cutoutRight}, ${cutoutTop}, ${cutoutRight}, ${cutoutTop + radius}\n              L ${cutoutRight}, ${cutoutBottom - radius}\n              Q ${cutoutRight}, ${cutoutBottom}, ${cutoutRight - radius}, ${cutoutBottom}\n              L ${cutoutLeft + radius}, ${cutoutBottom}\n              Q ${cutoutLeft}, ${cutoutBottom}, ${cutoutLeft}, ${cutoutBottom - radius}\n              L ${cutoutLeft}, ${containerHeight}\n              L ${containerWidth}, ${containerHeight}\n              L ${containerWidth}, 0`;\n    }\n\n    return `M 0, 0\n            L 0, ${containerHeight}\n            L ${cutoutLeft}, ${containerHeight}\n            L ${cutoutLeft}, ${cutoutTop}\n            L ${cutoutRight}, ${cutoutTop}\n            L ${cutoutRight}, ${cutoutBottom}\n            L ${cutoutLeft}, ${cutoutBottom}\n            L ${cutoutLeft}, ${containerHeight}\n            L ${containerWidth}, ${containerHeight}\n            L ${containerWidth}, 0`;\n  }\n\n  const svgStyle: React.CSSProperties = {\n    height: containerHeight,\n    width: containerWidth,\n    pointerEvents: disableMaskInteraction ? 'auto' : 'none',\n  }\n\n  const maskFilterStyle: React.CSSProperties | undefined = maskBackdropFilter ? {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    width: containerWidth,\n    height: containerHeight,\n    pointerEvents: 'none',\n    backdropFilter: maskBackdropFilter,\n    WebkitBackdropFilter: maskBackdropFilter,\n    clipPath: targetInfo ? `url(#${pathId})` : undefined,\n    zIndex: -1,\n  } : undefined;\n\n  return (\n    <>\n      {maskBackdropFilter && targetInfo && <div style={maskFilterStyle} />}\n      <svg style={svgStyle}>\n        {targetInfo &&\n          <defs>\n            <clipPath id={pathId}>\n              <path d={getCutoutPath(targetInfo)}\n              />\n            </clipPath>\n          </defs>\n        }\n\n        <rect\n          onClick={disableCloseOnClick ? undefined : close}\n          x={0}\n          y={0}\n          width={containerWidth}\n          height={containerHeight}\n          fill={fillColor ?? 'black'}\n          fillOpacity={maskOpacity ?? 0.3}\n          pointerEvents='auto'\n          clipPath={targetInfo ? `url(#${pathId})` : undefined}\n        />\n      </svg>\n    </>\n  );\n}\n","import { focusableSelector } from \"./constants\";\nimport { getTargetPosition } from \"./positioning\";\n\nexport interface Coords {\n  x: number;\n  y: number;\n}\n\nexport interface Dims {\n  width: number;\n  height: number;\n}\n\nexport interface ElementInfo {\n  dims: Dims;\n  coords: Coords;\n}\n\nexport function isValidCoords(coords: Coords): boolean {\n  if (!coords) {\n    return false;\n  } else if ((!coords.x && coords.x !== 0) || (!coords.y && coords.y !== 0)) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\nexport function isValidDims(dims: Dims): boolean {\n  if (!dims) {\n    return false;\n  } else if ((!dims.height && dims.height !== 0) || (!dims.width && dims.height !== 0)) {\n    return false;\n  } else if (dims.height < 0 || dims.width < 0) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\nexport function dist(a: Coords, b: Coords): number {\n  if (!isValidCoords(a) || !isValidCoords(b)) {\n    return;\n  }\n\n  return Math.sqrt(\n    Math.pow((Math.abs(a.x - b.x)), 2) +\n    Math.pow((Math.abs(a.y - b.y)), 2))\n}\n\nexport function areaDiff(a: Dims, b: Dims): number {\n  if (!isValidDims(a) || !isValidDims(b)) {\n    return;\n  }\n\n  return Math.abs((a.height * a.width) - (b.height * b.width));\n}\n\nexport function getElementCoords(element: Element): Coords {\n  if (!element) {\n    return;\n  }\n  const elementData: ClientRect = element.getBoundingClientRect();\n  return {\n    x: elementData.left,\n    y: elementData.top\n  }\n}\n\nexport function getElementDims(element: Element): Dims {\n  if (!element) {\n    return;\n  }\n  const elementData = element.getBoundingClientRect();\n  return {\n    width: elementData.width,\n    height: elementData.height\n  }\n}\n\n//https://gist.github.com/gre/296291b8ce0d8fe6e1c3ea4f1d1c5c3b\nexport function getNearestScrollAncestor(element: Element): Element {\n  const regex = /(auto|scroll)/;\n\n  const style = (el: Element, prop: string) =>\n    getComputedStyle(el, null).getPropertyValue(prop);\n\n  const scroll = (el: Element) =>\n    regex.test(\n      style(el, \"overflow\") +\n      style(el, \"overflow-y\") +\n      style(el, \"overflow-x\"));\n\n  if (!element || isDefaultScrollingElement(element)) {\n    return getDefaultScrollingElement();\n  } else {\n    if (scroll(element)) {\n      return element;\n    } else {\n      return getNearestScrollAncestor(element.parentElement)\n    }\n  }\n}\n\n//https://github.com/GreenGremlin/scroll-doc/blob/master/index.js\nexport function getDefaultScrollingElement(): Element {\n  const windowStart: number = window.pageYOffset; //slightly better support than scrollY\n  document.documentElement.scrollTop = windowStart + 1;\n  if (window.pageXOffset > windowStart) {\n    document.documentElement.scrollTop = windowStart; //reset\n    return document.documentElement;\n  } else {\n    return document.scrollingElement || document.body;\n  }\n}\n\nexport function isDefaultScrollingElement(root: Element) {\n  return root.isSameNode(document.body) || root.isSameNode(document.scrollingElement) || root.isSameNode(document.documentElement);\n}\n\n//if we're not putting the portal in a custom container, it needs to be at the body level\nexport function getValidPortalRoot(root: Element) {\n  // check for the potential default scrolling elements that might be returned from the above function\n  if (isDefaultScrollingElement(root)) {\n    return document.body;\n  } else {\n    return root;\n  }\n}\n\nexport function getCombinedData(aCoords: Coords, aDims: Dims, bCoords: Coords, bDims: Dims): { coords: Coords, dims: Dims } {\n\n  // generates similar data as getBoundingClientRect but using hypothetical positions\n  const generateBounds = (coords: Coords, dims: Dims): { left: number, right: number, top: number, bottom: number } => {\n    return {\n      left: coords.x,\n      right: coords.x + dims.width,\n      top: coords.y,\n      bottom: coords.y + dims.height\n    }\n  }\n\n  const mostExtreme = (a: number, b: number, largest: boolean): number => {\n    return (a > b)\n      ? (largest ? a : b)\n      : (largest ? b : a)\n  }\n\n  const aBounds = generateBounds(aCoords, aDims);\n  const bBounds = generateBounds(bCoords, bDims);\n\n\n  const left: number = mostExtreme(aBounds.left, bBounds.left, false);\n  const right: number = mostExtreme(aBounds.right, bBounds.right, true);\n  const top: number = mostExtreme(aBounds.top, bBounds.top, false);\n  const bottom: number = mostExtreme(aBounds.bottom, bBounds.bottom, true);\n\n  return {\n    coords: {\n      x: left,\n      y: top\n    },\n    dims: {\n      height: bottom - top,\n      width: right - left\n    }\n  }\n}\n\n// determines if a can fit within b\nexport function fitsWithin(aDims: Dims, bDims: Dims) {\n  if (!isValidDims(aDims) || !isValidDims(bDims)) {\n    return false;\n  }\n\n  return aDims.height <= bDims.height && aDims.width <= bDims.width;\n}\n\n// determines if a does fit within b at the given coords\nexport function isWithinAt(aDims: Dims, bDims: Dims, aCoords?: Coords, bCoords?: Coords) {\n  if (!isValidDims(aDims) || !isValidDims(bDims)) {\n    return false;\n  }\n\n  const validCoordsA: Coords = isValidCoords(aCoords) ? aCoords : { x: 0, y: 0 };\n  const validCoordsB: Coords = isValidCoords(bCoords) ? bCoords : { x: 0, y: 0 };\n  const fitsDims: boolean = fitsWithin(aDims, bDims);\n  const fitsHorizontally: boolean = (validCoordsA.x >= validCoordsB.x) && (validCoordsA.x + aDims.width <= validCoordsB.x + bDims.width);\n  const fitsVertically: boolean = (validCoordsA.y >= validCoordsB.y) && (validCoordsA.y + aDims.height <= validCoordsB.y + bDims.height);\n\n  return fitsDims && fitsHorizontally && fitsVertically;\n}\n\nexport function getFocusableElements(root: Element, includeSelf?: boolean): HTMLElement[] {\n\n  const focusableChildren = root.querySelectorAll(focusableSelector)\n  let array: HTMLElement[] = [];\n  if (includeSelf && root.matches(focusableSelector)) {\n    array.push(root as HTMLElement);\n  }\n  if (focusableChildren.length > 0) {\n    focusableChildren.forEach(el => array.push(el as HTMLElement));\n  } \n\n  return array;\n}\n\n// helper function to get first/last focusable elements if possible\nexport function getEdgeFocusables(defaultElement: HTMLElement, container?: HTMLElement, includeSelf?: boolean): { start: HTMLElement, end: HTMLElement } {\n  if (container) {\n    const containerFocusables: HTMLElement[] = getFocusableElements(container, includeSelf);\n    if (containerFocusables.length > 0) {\n      return {\n        start: containerFocusables[0],\n        end: containerFocusables[containerFocusables.length - 1]\n      }\n    }\n  }\n\n  return {\n    start: defaultElement,\n    end: defaultElement\n  }\n}\n\nexport function getTargetInfo(root: Element, target?: HTMLElement): ElementInfo | undefined {\n  if (!root || !target) {\n    return;\n  }\n  const dims: Dims = getElementDims(target);\n  const coords: Coords = getTargetPosition(root, target);\n\n  return {\n    coords,\n    dims\n  }\n}\n\nexport function isForeignTarget(root: Element, selector: string): boolean {\n  return !root.querySelector(selector);\n}\n","export const TAB_KEYCODE = 9;\n\n//  selector adapted from https://gist.github.com/r3lk3r/0030bab99347a2326334e00b23188cab#file-focusloopingutil-js\nexport const focusableSelector: string = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, [tabindex]:not([tabindex^=\"-\"]):not([disabled]), [contenteditable]';\n","\nimport { Coords, getElementCoords, dist, getElementDims, Dims, getCombinedData, fitsWithin, isWithinAt, isForeignTarget } from \"./dom\";\nimport { getViewportCenter, addAppropriateOffset, applyCenterOffset, centerViewportAroundElements, centerViewportAroundElement, getCurrentScrollOffset } from \"./offset\";\nimport { getViewportDims, getViewportScrollEnd, getScrolledViewportPosition, getViewportScrollStart, isElementInView, getViewportStart } from \"./viewport\";\n\nexport enum CardinalOrientation {\n  EAST = 'east',\n  SOUTH = 'south',\n  WEST = 'west',\n  NORTH = 'north',\n  CENTER = 'center',\n  EASTNORTH = 'east-north',\n  EASTSOUTH = 'east-south',\n  SOUTHEAST = 'south-east',\n  SOUTHWEST = 'south-west',\n  WESTSOUTH = 'west-south',\n  WESTNORTH = 'west-north',\n  NORTHWEST = 'north-west',\n  NORTHEAST = 'north-east'\n}\n\nexport interface OrientationCoords {\n  orientation: CardinalOrientation;\n  coords: Coords;\n}\n\nexport interface GetTooltipPositionArgs {\n  target: HTMLElement;\n  tooltip: HTMLElement;\n  padding: number;\n  tooltipSeparation: number;\n  root: Element;\n  orientationPreferences?: CardinalOrientation[];\n  getPositionFromCandidates?: (candidates: OrientationCoords[]) => OrientationCoords;\n  disableAutoScroll?: boolean;\n  allowForeignTarget?: boolean;\n  selector?: string;\n}\n\nfunction getTooltipPositionCandidates(target: HTMLElement, tooltip: HTMLElement, padding: number, tooltipDistance: number, includeAllPositions?: boolean): OrientationCoords[] {\n  if (!target || !tooltip) {\n    return;\n  }\n\n  const tooltipDims: Dims = getElementDims(tooltip);\n  const targetCoords: Coords = getElementCoords(target);\n  const targetDims: Dims = getElementDims(target);\n  const centerX: number = targetCoords.x - ((tooltipDims.width - targetDims.width) / 2);\n  const centerY: number = targetCoords.y - ((tooltipDims.height - targetDims.height) / 2);\n  const eastOffset: number = targetCoords.x + targetDims.width + padding + tooltipDistance;\n  const southOffset: number = targetCoords.y + targetDims.height + padding + tooltipDistance;\n  const westOffset: number = targetCoords.x - tooltipDims.width - padding - tooltipDistance;\n  const northOffset: number = targetCoords.y - tooltipDims.height - padding - tooltipDistance;\n\n  const east: Coords = { x: eastOffset, y: centerY }\n  const south: Coords = { x: centerX, y: southOffset }\n  const west: Coords = { x: westOffset, y: centerY };\n  const north: Coords = { x: centerX, y: northOffset };\n  const center: Coords = applyCenterOffset(targetCoords, targetDims, tooltipDims);\n\n  const standardPositions = [\n    { orientation: CardinalOrientation.EAST, coords: east },\n    { orientation: CardinalOrientation.SOUTH, coords: south },\n    { orientation: CardinalOrientation.WEST, coords: west },\n    { orientation: CardinalOrientation.NORTH, coords: north },\n  ];\n\n  let additionalPositions: OrientationCoords[];\n  if (includeAllPositions) {\n    const eastAlign: number = targetCoords.x - (tooltipDims.width - targetDims.width) + padding;\n    const southAlign: number = targetCoords.y - (tooltipDims.height - targetDims.height) + padding;\n    const westAlign: number = targetCoords.x - padding;\n    const northAlign: number = targetCoords.y - padding;\n\n    const eastNorth: Coords = { x: eastOffset, y: northAlign }\n    const eastSouth: Coords = { x: eastOffset, y: southAlign }\n    const southEast: Coords = { x: eastAlign, y: southOffset }\n    const southWest: Coords = { x: westAlign, y: southOffset }\n    const westSouth: Coords = { x: westOffset, y: southAlign }\n    const westNorth: Coords = { x: westOffset, y: northAlign }\n    const northWest: Coords = { x: westAlign, y: northOffset }\n    const northEast: Coords = { x: eastAlign, y: northOffset }\n\n    additionalPositions = [\n      { orientation: CardinalOrientation.EASTNORTH, coords: eastNorth },\n      { orientation: CardinalOrientation.EASTSOUTH, coords: eastSouth },\n      { orientation: CardinalOrientation.SOUTHEAST, coords: southEast },\n      { orientation: CardinalOrientation.SOUTHWEST, coords: southWest },\n      { orientation: CardinalOrientation.WESTSOUTH, coords: westSouth },\n      { orientation: CardinalOrientation.WESTNORTH, coords: westNorth },\n      { orientation: CardinalOrientation.NORTHWEST, coords: northWest },\n      { orientation: CardinalOrientation.NORTHEAST, coords: northEast }\n    ]\n  }\n\n  return [\n    ...standardPositions,\n    ...additionalPositions,\n    { orientation: CardinalOrientation.CENTER, coords: center }\n  ]\n}\n\n// simple reducer who selects for coordinates closest to the current center of the viewport\nfunction getCenterReducer(root: Element, tooltip: HTMLElement, target: HTMLElement, predictViewport?: boolean):\n  ((acc: OrientationCoords, cur: OrientationCoords, ind: number, arr: OrientationCoords[]) => OrientationCoords) {\n  const currentCenter: Coords = getViewportCenter(root, tooltip);\n\n  // store the center of the predicted viewport location with the tooltip at acc\n  // to have a meaningful distance comparison\n  let accCenter: Coords = currentCenter;\n\n  const getCenter = (coords: Coords) => {\n    if (predictViewport && (!isElementInView(root, target) || !isElementInView(root, tooltip, coords, true))) {\n      return getViewportCenter(root, tooltip, getScrolledViewportPosition(root, centerViewportAroundElements(root, tooltip, target, coords)));\n    } else {\n      return currentCenter;\n    }\n  }\n\n  return (acc: OrientationCoords, cur: OrientationCoords, ind: number, arr: OrientationCoords[]): OrientationCoords => {\n    if (cur.orientation === CardinalOrientation.CENTER) { //ignore centered coords since those will always be closest to the center\n      if (ind === arr.length - 1 && acc === undefined) { //unless  we're at the end and we still haven't picked a coord\n        return cur;\n      } else {\n        return acc;\n      }\n    } else if (acc === undefined) {\n      accCenter = getCenter(cur.coords);\n      return cur;\n    } else {\n      const center: Coords = getCenter(cur.coords);\n\n      if (dist(center, cur.coords) > dist(accCenter, acc.coords)) {\n        return acc;\n      } else {\n        accCenter = center;\n        return cur;\n      }\n    }\n  }\n}\n\n// complex candidate reducer function that tries to place the tooltip as close to the center of the \n// screen as possible, even after the screen has scrolled to a particular location.\nfunction chooseBestTooltipPosition(preferredCandidates: OrientationCoords[], root: Element, tooltip: HTMLElement, target: HTMLElement, scrollDisabled: boolean): OrientationCoords {\n  if (preferredCandidates.length === 1) {\n    //if there's only a single pref candidate, use that\n    return preferredCandidates[0];\n  } else if (scrollDisabled) {\n    // if scrolling is disabled, there's not much we can do except use the naive center reducer\n    return preferredCandidates.reduce(getCenterReducer(root, tooltip, target, false), undefined);\n  } else {\n    // scrolling is allowed, which means we have to figure out:\n    // 1. what candidates are valid positions (not out of the scrolling root's bounds)\n    // 2. which positions are absolutely compatible (allow both target & tooltip to fit within the viewport at the same time)\n    // 3. which positions are currently compatible (allow both target & tooltip to fit with the CURRENT viewport)\n    // 4. which of those positions is *best* - use same closest-to-center heuristic.\n    // priority is 3 > 2 > 1 for the pool of positions from which 4 is chosen\n\n    const viewportDims: Dims = getViewportDims(root);\n    const viewportScrollStart: Coords = getViewportScrollStart(root);\n    const viewportCurrentStart: Coords = getViewportStart(root);\n    const viewportScrollEnd: Coords = getViewportScrollEnd(root);\n    const tooltipDims: Dims = getElementDims(tooltip);\n    const targetDims: Dims = getElementDims(target);\n    const targetCoords: Coords = getElementCoords(target);\n    const curriedGetCombinedData = (coords: Coords) => getCombinedData(coords, tooltipDims, targetCoords, targetDims);\n\n    const validPositions: OrientationCoords[] = preferredCandidates.filter(getInBoundsFilter(tooltipDims, viewportScrollStart, viewportScrollEnd));\n    const absoluteCompatiblePositions: OrientationCoords[] = validPositions.filter(getAbsoluteCompatibleArrangementFilter(curriedGetCombinedData, viewportDims));\n    const currentCompatiblePositions: OrientationCoords[] = absoluteCompatiblePositions.filter(getCurrentInViewFilter(curriedGetCombinedData, viewportDims, viewportCurrentStart));\n\n    // // if possible, use only those positions which don't force a scroll. Default back to those which can fit in the viewport, even if that means scrolling\n    const compatiblePositions: OrientationCoords[] = currentCompatiblePositions.length > 0 ? currentCompatiblePositions : absoluteCompatiblePositions;\n\n    // if there are NO compatible positions, the viewport is too small to accomodate both the target/tooltip, in any arrangement.\n    // we default to our valid positions, even if that means placing the elements slightly off screen.\n    const filteredList = compatiblePositions.length > 0 ? compatiblePositions : validPositions;\n\n    return filteredList.reduce(getCenterReducer(root, tooltip, target, true), undefined);\n  }\n}\n\n// filter out any positions which would have the tooltip be out of the bounds of the root container \n// (i.e. in a position that the viewport can't \"reach\"/scroll to)\nfunction getInBoundsFilter(tooltipDims: Dims, viewportScrollStart: Coords, viewportScrollEnd: Coords): (oc: OrientationCoords) => boolean {\n  return (oc: OrientationCoords): boolean => {\n    const coords: Coords = oc.coords;\n    return !(coords.x < viewportScrollStart.x || coords.y < viewportScrollStart.y ||\n      (coords.x + tooltipDims.width) > viewportScrollEnd.x || (coords.y + tooltipDims.height) > viewportScrollEnd.y)\n  }\n}\n\n// filters out any positions which would cause the target/tooltip to not fit within the viewport\nfunction getAbsoluteCompatibleArrangementFilter(curriedGetCombinedData: (coords: Coords) => { dims: Dims, coords: Coords }, viewportDims: Dims): (oc: OrientationCoords) => boolean {\n  return (oc: OrientationCoords): boolean => {\n    const coords: Coords = oc.coords;\n    // we only care about the resultant dims but the input coords are critical here\n    const { dims: combinedDims } = curriedGetCombinedData(coords);\n\n    return fitsWithin(combinedDims, viewportDims);\n  }\n}\n\nfunction getCurrentInViewFilter(curriedGetCombinedData: (coords: Coords) => { dims: Dims, coords: Coords }, viewportDims: Dims, viewportCurrentStart: Coords): (oc: OrientationCoords) => boolean {\n  return (oc: OrientationCoords): boolean => {\n    const coords: Coords = oc.coords;\n\n    const { dims: combinedDims, coords: combinedCoords } = curriedGetCombinedData(coords);\n\n    return isWithinAt(combinedDims, viewportDims, combinedCoords, viewportCurrentStart);\n  }\n}\n\nfunction getPreferredCandidates(candidates: OrientationCoords[], orientationPreferences?: CardinalOrientation[]): OrientationCoords[] {\n  if (!orientationPreferences || orientationPreferences.length === 0) {\n    return candidates;\n  } else if (orientationPreferences.length === 1) {\n    const specifiedCandidate = candidates.find((oc: OrientationCoords) => oc.orientation === orientationPreferences[0])\n    if (specifiedCandidate) {\n      return [specifiedCandidate];\n    } else {\n      return candidates; // if the specified orientation isn't available for whatever reason, default to standard behavior\n    }\n  } else {\n    const preferenceFilter = (cc: OrientationCoords) => orientationPreferences.indexOf(cc.orientation) !== -1;\n    return candidates.filter(preferenceFilter);\n  }\n}\n\nfunction restrictToCurrentViewport(root: Element, coords: Coords, dims: Dims, padding: number): Coords {\n  if (!root) {\n    return coords;\n  }\n\n  const viewportStart: Coords = getCurrentScrollOffset(root);\n  const viewportDims: Dims = getViewportDims(root);\n  const viewportEnd: Coords = {\n    x: viewportStart.x + viewportDims.width,\n    y: viewportStart.y + viewportDims.height\n  }\n  const sx = viewportStart.x + padding;\n  const sy = viewportStart.y + padding;\n  const ex = viewportEnd.x - dims.width - padding;\n  const ey = viewportEnd.y - dims.height - padding;\n\n  let x: number = coords.x;\n  let y: number = coords.y;\n\n  if (coords.x < sx) {\n    x = sx;\n  } else if ((coords.x + dims.width) > ex) {\n    x = ex;\n  }\n\n  if (coords.y < sy) {\n    y = sy;\n  } else if ((coords.y + dims.height) > ey) {\n    y = ey;\n  }\n\n  return { x, y }\n}\n\nexport function getTooltipPosition(args: GetTooltipPositionArgs): OrientationCoords {\n  const { target, tooltip, padding, tooltipSeparation, orientationPreferences, getPositionFromCandidates, root: tourRoot, disableAutoScroll: scrollDisabled, allowForeignTarget, selector } = args;\n  const center: Coords = target ? getViewportCenter(tourRoot, tooltip, getScrolledViewportPosition(tourRoot, centerViewportAroundElement(tourRoot, target))) : getViewportCenter(tourRoot, tooltip)\n  const defaultPosition: Coords = addAppropriateOffset(tourRoot, center);\n\n  if (!tooltip || !tourRoot) {\n    return;\n  }\n\n  if (!target) {\n    return {orientation: null, coords: defaultPosition};\n  }\n\n  const foreignTarget: boolean = allowForeignTarget && isForeignTarget(tourRoot, selector);\n  const noScroll: boolean = scrollDisabled || foreignTarget;\n  const candidates: OrientationCoords[] = getTooltipPositionCandidates(target, tooltip, padding, tooltipSeparation, true);\n  const choosePosition = getPositionFromCandidates || ((cans: OrientationCoords[]) => chooseBestTooltipPosition(cans, tourRoot, tooltip, target, noScroll));\n\n  const rawPosition: OrientationCoords = choosePosition(getPreferredCandidates(candidates, orientationPreferences)); //position relative to current viewport\n\n  if (!rawPosition) {\n    return {orientation: CardinalOrientation.CENTER, coords: defaultPosition};\n  }\n\n  const adjustedPosition: OrientationCoords = {orientation: rawPosition.orientation, coords: addAppropriateOffset(tourRoot, rawPosition.coords)};\n\n  if (foreignTarget) {\n    return {orientation: adjustedPosition.orientation, coords: restrictToCurrentViewport(tourRoot, adjustedPosition.coords, getElementDims(tooltip), padding + tooltipSeparation)}\n  }\n\n  return adjustedPosition;\n}\n\nexport function getTargetPosition(root: Element, target: HTMLElement): Coords {\n  return addAppropriateOffset(root, getElementCoords(target));\n}\n","import { Coords, getElementCoords, Dims, isDefaultScrollingElement, getCombinedData, getElementDims } from \"./dom\";\nimport { getViewportStart, getViewportDims } from \"./viewport\";\n\nexport function getCurrentScrollOffset(root: Element): Coords {\n  return {\n    x: root.scrollLeft,\n    y: root.scrollTop\n  }\n}\n\nexport function addScrollOffset(root: Element, coords: Coords) {\n  const curOffset: Coords = getCurrentScrollOffset(root);\n  return {\n    x: coords.x + curOffset.x,\n    y: coords.y + curOffset.y\n  }\n}\n\nexport function addAppropriateOffset(root: Element, coords: Coords) {\n  if (!coords || !root) {\n    return;\n  }\n\n  // if there's a custom root, then we need to offset by that root's positioning relative to the window\n  // before adjusting for its scroll values\n  if (!isDefaultScrollingElement(root)) {\n    const rootCoords: Coords = getElementCoords(root);\n    return addScrollOffset(root, {\n      x: coords.x - rootCoords.x,\n      y: coords.y - rootCoords.y\n    })\n  } else {\n    return addScrollOffset(root, coords);\n  }\n}\n\n// apply a common offset calculation where b is centered relative to a. If b is larger than a, the result is that a will be centered within b.\n// b is the moveable element: the returned value will specify where to place b to achieve centering.\nexport function applyCenterOffset(aCoords: Coords, aDims: Dims, b: Dims): Coords {\n  return {\n    x: aCoords.x + (aDims.width / 2) - (b.width / 2),\n    y: aCoords.y + (aDims.height / 2) - (b.height / 2)\n  }\n}\n\nexport function centerViewportAroundElements(root: Element, a: HTMLElement, b: HTMLElement, aPosition?: Coords, bPosition?: Coords): Coords {\n  if (!root || !a || !b) {\n    return;\n  }\n\n  const aCoords = aPosition || getElementCoords(a);\n  const bCoords = bPosition || getElementCoords(b);\n  const aDims = getElementDims(a);\n  const bDims = getElementDims(b);\n  const {coords, dims} = getCombinedData(aCoords, aDims, bCoords, bDims);\n  return centerViewportAround(root, coords, dims);\n}\n\nexport function centerViewportAround(root: Element, coords: Coords, dims: Dims): Coords {\n  return applyCenterOffset(coords, dims, getViewportDims(root));\n}\n\n// get the coordinates the viewport would need to be placed for the element to be centered\nexport function centerViewportAroundElement(root: Element, element: HTMLElement): Coords {\n  const elementDims: Dims = getElementDims(element);\n  const elementCoords: Coords = getElementCoords(element);\n\n  return centerViewportAround(root, elementCoords, elementDims);\n}\n\n// get the center coord of the viewport. If element is provided, the return value is the origin \n// which would align that element's center with the viewport center. If atViewportPosition is provided,\n// gets the viewport's center at that position\nexport function getViewportCenter(root: Element, element?: HTMLElement, atViewportPosition?: Coords): Coords {\n  if (!root) {\n    return;\n  }\n  const startCoords: Coords = atViewportPosition || getViewportStart(root);\n  const viewportDims: Dims = getViewportDims(root);\n  const elementDims: Dims = element ? getElementDims(element) : {height: 0, width: 0}\n\n  return applyCenterOffset(startCoords, viewportDims, elementDims);\n}\n\n","import { Dims, Coords, getElementCoords, isDefaultScrollingElement, getElementDims, isWithinAt } from \"./dom\";\nimport { addAppropriateOffset, getCurrentScrollOffset } from \"./offset\";\n\nexport function getViewportHeight(root: Element): number {\n  return root.clientHeight;\n}\n\nexport function getViewportWidth(root: Element): number {\n  return root.clientWidth;\n}\n\nexport function getViewportDims(root: Element): Dims {\n  return {\n    width: getViewportWidth(root),\n    height: getViewportHeight(root)\n  }\n}\n\nexport function getViewportScrollHeight(root: Element): number {\n  return root.scrollHeight;\n}\n\nexport function getViewportScrollWidth(root: Element): number {\n  return root.scrollWidth;\n}\n\nexport function getViewportScrollDims(root: Element): Dims {\n  return {\n    width: getViewportScrollWidth(root),\n    height: getViewportScrollHeight(root)\n  }\n}\n\nexport function getViewportStart(root: Element): Coords {\n  if (isDefaultScrollingElement(root)) {\n    return {\n      x: 0,\n      y: 0\n    }\n  } else {\n    return getElementCoords(root);\n  }\n}\n\nexport function getViewportEnd(root: Element): Coords {\n  const startCoords: Coords = getViewportStart(root);\n  return {\n    x: startCoords.x + getViewportWidth(root),\n    y: startCoords.y + getViewportHeight(root)\n  }\n}\n\n\nexport function getViewportScrollStart(root: Element): Coords {\n  const curScrollOffset: Coords = getCurrentScrollOffset(root);\n  const start: Coords = getViewportStart(root);\n\n  return {\n    x: start.x - curScrollOffset.x,\n    y: start.y - curScrollOffset.y\n  }\n}\n\nexport function getViewportScrollEnd(root: Element): Coords {\n  const startCoords: Coords = getViewportScrollStart(root);\n  const { width, height } = getViewportScrollDims(root);\n  return {\n    x: startCoords.x + width,\n    y: startCoords.y + height\n  };\n}\n\nexport function isElementInView(root: Element, element: HTMLElement, atPosition?: Coords, needsAdjusting?: boolean): boolean {\n  if (!root || !element) {\n    return false;\n  }\n  const explicitPosition: Coords = atPosition && (needsAdjusting ? addAppropriateOffset(root, atPosition) : atPosition)\n  const position: Coords = explicitPosition || addAppropriateOffset(root, getElementCoords(element));\n  const elementDims: Dims = getElementDims(element);\n  const startCoords: Coords = addAppropriateOffset(root, getViewportStart(root));\n  const viewportDims: Dims = getViewportDims(root);\n\n  return isWithinAt(elementDims, viewportDims, position, startCoords);\n}\n\n// if directed to scroll to a position which is outside the bounds of the scrolling container, the \n// viewport will stop at the edges of that container. We want to get the coords that the viewport\n// will end up when given certain coords\nexport function getScrolledViewportPosition(root: Element, scrollDestination: Coords) {\n  const dims = getViewportDims(root);\n  const startCoords = getViewportScrollStart(root);\n  const endCoords = getViewportScrollEnd(root);\n\n  const rightmost = endCoords.x - dims.width;\n  const bottommost = endCoords.y - dims.height;\n\n  let coords: Coords = scrollDestination;\n\n  if (scrollDestination.x < startCoords.x) {\n    coords.x = startCoords.x;\n  } else if (scrollDestination.x > rightmost) {\n    coords.x = rightmost;\n  } else {\n    coords.x = scrollDestination.x;\n  }\n\n  if (scrollDestination.y < startCoords.y) {\n    coords.y = startCoords.y;\n  } else if (scrollDestination.y > bottommost) {\n    coords.y = bottommost;\n  } else {\n    coords.y = scrollDestination.y;\n  }\n\n  return coords;\n}","import * as React from 'react';\nimport { WalktourLogic } from './Walktour';\nimport { WalktourStyles, defaultStyles } from '../defaultstyles';\n\ninterface TooltipProps extends WalktourLogic {\n  styles?: WalktourStyles;\n}\n\nexport function Tooltip(props: TooltipProps) {\n  const {\n    next,\n    prev,\n    close,\n    stepContent: {\n      title,\n      description,\n      customTitleRenderer,\n      customDescriptionRenderer,\n      customFooterRenderer,\n      disableClose,\n      disableNext,\n      disablePrev,\n      nextLabel,\n      prevLabel,\n      closeLabel,\n    },\n    stepIndex,\n    allSteps,\n    styles,\n  } = {\n    styles: defaultStyles,\n    ...props\n  };\n\n  const tooltipStyle: React.CSSProperties = {\n    ...styles.tooltip,\n  }\n\n  const prevDisabled: boolean = disablePrev !== undefined ? disablePrev : stepIndex === 0;\n  const nextDisabled: boolean = disableNext !== undefined ? disableNext : stepIndex + 1 === allSteps.length;\n\n  return (\n    <div style={tooltipStyle}>\n      {customTitleRenderer\n        ? customTitleRenderer(title, props)\n        : (title &&\n          <div style={styles.title}>\n            {title}\n          </div>\n        )\n      }\n\n      {customDescriptionRenderer\n        ? customDescriptionRenderer(description, props)\n        : (\n          <div style={styles.description}>\n            {description}\n          </div>\n        )\n      }\n\n      {customFooterRenderer\n        ? customFooterRenderer(props)\n        : (\n          <div style={styles.footer}>\n            <button \n            onClick={() => close()} \n            style={{...styles.tertiaryButton, ...disableClose && styles.disabledButton}}\n            disabled={disableClose}\n            >\n              {closeLabel || \"close\"}\n            </button>\n            <button\n              onClick={prev}\n              disabled={prevDisabled}\n              style={{...styles.secondaryButton, ...prevDisabled && styles.disabledButton}}\n            >\n              {prevLabel || \"prev\"}\n            </button>\n            <button\n              onClick={() => next()}\n              disabled={nextDisabled}\n              style={{...styles.primaryButton, ...nextDisabled && styles.disabledButton}}\n            >\n              {nextLabel || \"next\"}\n            </button>\n          </div>\n        )}\n    </div>\n  )\n}","import { CSSProperties } from \"react\";\n\n\nexport interface WalktourStyles {\n  tooltip: CSSProperties;\n  footer: CSSProperties;\n  title: CSSProperties;\n  description: CSSProperties;\n  primaryButton: CSSProperties;\n  secondaryButton: CSSProperties;\n  tertiaryButton: CSSProperties;\n  disabledButton: CSSProperties;\n}\n\nconst contentMargin: number = 4;\nconst baseButtonStyle: React.CSSProperties = {\n  cursor: 'pointer',\n  padding: '4px 16px', \n  textAlign: 'center',\n  border: 0,\n  borderRadius: 3,\n  backgroundColor: '#0084ff',\n  color: '#fff',\n  fontSize: 14,\n  margin: contentMargin\n};\n\nexport const defaultStyles: WalktourStyles = {\n  tooltip: {\n    display: 'flex', \n    flexDirection: 'column', \n    zIndex: 9999,\n    fontFamily: 'Roboto, sans-serif',\n    fontSize: 14,\n    backgroundColor: 'white',\n    padding: '10px 10px 5px 10px',\n    borderRadius: '5px',\n    boxShadow: '0 3px 8px 0 rgba(0,0,0,.25)',\n    color: '#4d4d4d',\n    minWidth: 215, //so that buttons have adequate spacing\n    maxWidth: 285,\n  },\n  footer: {\n    display: 'flex',\n    justifyContent: 'center',\n    marginTop: contentMargin\n  },\n  title: {\n    margin: contentMargin,\n    fontSize: 24,\n  },\n  description: {\n    margin: contentMargin,\n  },\n  primaryButton: {\n    ...baseButtonStyle,\n    backgroundColor: \"#0084ff\",\n    color: \"#ffffff\"\n  },\n  secondaryButton: {\n    ...baseButtonStyle,\n    backgroundColor: \"#8400ff\",\n    color: \"#fff\",\n    border: \"solid 1px #8400ff\"\n  },\n  tertiaryButton: {\n    ...baseButtonStyle,\n    marginRight: 'auto',\n    backgroundColor: `transparent`,\n    color: \"#025c53\",\n    border: \"solid 1px #025c53\"\n  },\n  disabledButton: {\n    ...baseButtonStyle,\n    backgroundColor: \"#bebebe\",\n    color: \"#989898\",\n    cursor: \"default\"\n  },\n}","import { Coords } from \"./dom\";\nimport { addAppropriateOffset, centerViewportAroundElement } from \"./offset\";\n\nexport function scrollToElement(root: Element, element: HTMLElement, disableSmoothScrolling?: boolean): void {\n  if (!root || !element) {\n    return;\n  }\n\n  const coords = addAppropriateOffset(root, centerViewportAroundElement(root, element));\n\n  scrollToDestination(root, coords, disableSmoothScrolling);\n}\n\nexport function scrollToDestination(root: Element, destination: Coords, disableSmoothScrolling?: boolean): void {\n  if (!root || !destination) {\n    return;\n  }\n  // check if the 'scrollBehavior' property is supported. Support for this property is consistent\n  // with support for scrollToOptions, and if it's supported we can scroll smoothly\n  const smoothScrollingIsSupported = 'scrollBehavior' in document.documentElement.style;\n  if (smoothScrollingIsSupported && !disableSmoothScrolling) {\n    const scrollOptions: ScrollToOptions = {\n      top: destination.y,\n      left: destination.x,\n      behavior: 'smooth'\n    }\n\n    root.scrollTo(scrollOptions);\n  } else {\n    root.scrollTop = destination.y;\n    root.scrollLeft = destination.x;\n  }\n}","import { Coords, dist, Dims, areaDiff, fitsWithin, getElementDims, getEdgeFocusables, isForeignTarget } from \"./dom\";\nimport { getTargetPosition, GetTooltipPositionArgs, getTooltipPosition, OrientationCoords } from \"./positioning\";\nimport { isElementInView, getViewportDims } from \"./viewport\";\nimport { TAB_KEYCODE } from \"./constants\";\n\n//miscellaneous tour utilities\n\nexport function debounce<T extends any[]>(f: (...args: T) => void, interval: number = 300) {\n  let timeoutId: number;\n  return (...args: T) => {\n    if (timeoutId) {\n      window.clearTimeout(timeoutId);\n    }\n    timeoutId = window.setTimeout(() => f(...args), interval);\n  }\n}\n\nexport function getIdString(base: string, identifier?: string): string {\n  return `${base}${identifier ? `-${identifier}` : ``}`\n}\n\nexport function setTargetWatcher(callback: () => void, interval: number): (() => void) {\n  const intervalId: number = window.setInterval(callback, interval);\n\n  return () => window.clearInterval(intervalId);\n}\n\nexport interface SetTourUpdateListenerArgs {\n  update: () => void;\n  customSetListener?: (update: () => void) => void;\n  customRemoveListener?: (update: () => void) => void;\n  event?: string; // default is resize event\n}\n\nexport function setTourUpdateListener(args: SetTourUpdateListenerArgs) {\n  const { update, customSetListener, customRemoveListener, event } = { event: 'resize', ...args }\n  if (customSetListener && customRemoveListener) {\n    customSetListener(update);\n    return () => customRemoveListener(update);\n  } else {\n    window.addEventListener(event, update)\n    return () => window.removeEventListener(event, update);\n  }\n}\n\ninterface FocusTrapArgs {\n  start: HTMLElement;\n  end: HTMLElement;\n  beforeStart?: HTMLElement;\n  afterEnd?: HTMLElement;\n  // element that should be excluded from the focus trap but may obtain focus.\n  // any focus changes from this element will be directed back to the trap.\n  // behavior is based on \"verify address\" example from https://www.w3.org/TR/wai-aria-practices/examples/dialog-modal/dialog.html\n  lightningRod?: HTMLElement;\n}\n\n// helper function to create a keyboard focus trap, potentially including multiple elements\nfunction getFocusTrapHandler(args: FocusTrapArgs): (e: KeyboardEvent) => void {\n  const { start, end, beforeStart, afterEnd, lightningRod } = args;\n  return (e: KeyboardEvent) => {\n    if (e.keyCode === TAB_KEYCODE) {\n      if (e.shiftKey && e.target === start) {\n        e.preventDefault();\n        beforeStart ? beforeStart.focus() : end.focus();\n      } else if (!e.shiftKey && e.target === end) {\n        e.preventDefault();\n        afterEnd ? afterEnd.focus() : start.focus();\n      } else if (e.target === lightningRod) {\n        e.preventDefault();\n        start.focus();\n      }\n    }\n  }\n}\n\nexport const setFocusTrap = (tooltipContainer: HTMLElement, target?: HTMLElement, disableMaskInteraction?: boolean): (() => void) => {\n  if (!tooltipContainer) {\n    return;\n  }\n\n  const { start: tooltipFirst, end: tooltipLast } = getEdgeFocusables(tooltipContainer, tooltipContainer);\n  const { start: targetFirst, end: targetLast } = getEdgeFocusables(undefined, target, true);\n\n  let tooltipBeforeStart: HTMLElement;\n  let tooltipAfterEnd: HTMLElement;\n  let targetTrapHandler: (e: KeyboardEvent) => void;\n\n  if (target && !disableMaskInteraction && targetFirst && targetLast) {\n    tooltipAfterEnd = targetFirst;\n    tooltipBeforeStart = targetLast;\n    targetTrapHandler = getFocusTrapHandler({ start: targetFirst, end: targetLast, beforeStart: tooltipLast, afterEnd: tooltipFirst })\n    target.addEventListener('keydown', targetTrapHandler);\n  }\n\n  const tooltipTrapHandler = getFocusTrapHandler({ start: tooltipFirst, end: tooltipLast, beforeStart: tooltipBeforeStart, afterEnd: tooltipAfterEnd, lightningRod: tooltipContainer });\n  tooltipContainer.addEventListener('keydown', tooltipTrapHandler);\n\n  return () => {\n    if (target) {\n      target.removeEventListener('keydown', targetTrapHandler);\n    }\n\n    tooltipContainer.removeEventListener('keydown', tooltipTrapHandler);\n  }\n}\n\ninterface NaiveShouldScrollArgs {\n  root: Element;\n  tooltip: HTMLElement;\n  tooltipPosition: Coords;\n  target: HTMLElement;\n}\n\nfunction naiveShouldScroll(args: NaiveShouldScrollArgs): boolean {\n  const { root, tooltip, tooltipPosition, target } = args;\n\n  if (!isElementInView(root, tooltip, tooltipPosition)) {\n    return true;\n  }\n\n  if (!isElementInView(root, target)) {\n    return fitsWithin(getElementDims(target), getViewportDims(root));\n  }\n\n  return false;\n}\nexport interface ShouldScrollArgs extends NaiveShouldScrollArgs {\n  disableAutoScroll?: boolean;\n  allowForeignTarget?: boolean;\n  selector?: string;\n}\n\nexport function shouldScroll(args: ShouldScrollArgs): boolean {\n  const { root, tooltip, target, disableAutoScroll, allowForeignTarget, selector: targetSelector } = args;\n  if (!root || !tooltip || !target) {\n    return false;\n  }\n\n  if (disableAutoScroll) {\n    return false;\n  }\n\n  if (allowForeignTarget && targetSelector) {\n    return !isForeignTarget(root, targetSelector);\n  }\n  return naiveShouldScroll({ ...args });\n}\n\nexport interface TargetChangedArgs {\n  root: Element;\n  target: HTMLElement;\n  targetCoords: Coords;\n  targetDims: Dims;\n  rerenderTolerance: number;\n}\nexport function targetChanged(args: TargetChangedArgs): boolean {\n  const { root, target, targetCoords, targetDims, rerenderTolerance } = args;\n  if (!target && !targetCoords && !targetDims) {\n    return false;\n  }\n\n  // when the target / target data are out of sync. usually due to a movingTarget, i.e. the target arg is more up to date than the pos/dims args\n  if ((!target && targetCoords && targetDims) || (target && !targetCoords && !targetDims)) {\n    return true;\n  }\n\n  const currentTargetSize: Dims = getElementDims(target);\n  const currentTargetPosition: Coords = getTargetPosition(root, target);\n\n  const sizeChanged: boolean = areaDiff(currentTargetSize, targetDims) > rerenderTolerance;\n  const positionChanged: boolean = dist(currentTargetPosition, targetCoords) > rerenderTolerance;\n\n  return sizeChanged || positionChanged;\n}\n\nexport interface TooltipDesyncArgs extends GetTooltipPositionArgs {\n tooltipPosition: Coords;\n}\n\n// if there's no target, we need to ensure that the tooltip is centered, even if the window/container/scroll changes \n// if a target exists, there's not a tooltip desync in this context; there are two other functions\n// to determine if the tooltip/target are out of sync - this is solely for non-target cases\nexport function tooltipDesync(args: TooltipDesyncArgs): boolean {\n  const { target, root, tooltip, tooltipPosition: currentPosition } = args;\n  if (target || !root || !tooltip) {\n    return false;\n  }\n\n  const newPosition: OrientationCoords = getTooltipPosition({...args})\n\n  // if there's a difference between the newly calculated position and the current position, we need to update\n  return dist(newPosition.coords, currentPosition) !== 0;\n  \n}\n\nexport interface ShouldUpdateArgs extends TargetChangedArgs, ShouldScrollArgs, TooltipDesyncArgs { }\n\nexport function shouldUpdate(args: ShouldUpdateArgs): boolean {\n  const { root, tooltip } = args;\n  if (!root || !tooltip) {\n    return false; // bail if these aren't present; need them for calculations\n  }\n\n  return targetChanged({ ...args }) || shouldScroll({ ...args }) || tooltipDesync({...args})\n}\n\nexport const takeActionIfValid = async (action: () => void, actionValidator?: () => Promise<boolean>) => {\n  if (actionValidator) {\n    const valid: boolean = await actionValidator();\n    if (valid) {\n      action();\n    }\n  } else {\n    action();\n  }\n}\n\nexport const setNextOnTargetClick = (target: HTMLElement, next: (fromTarget?: boolean) => void, validateNext?: () => Promise<boolean>): (() => void) => {\n  if (!target) {\n    return;\n  }\n\n  // if valid, call a handler which 1. calls the tetheredAction function and 2. removes itself from the target\n  const clickHandler = () => {\n    const actionWithCleanup = () => {\n      next(true);\n      target.removeEventListener('click', clickHandler);\n    }\n\n    takeActionIfValid(actionWithCleanup, validateNext)\n  }\n\n  target.addEventListener('click', clickHandler);\n  return () => target.removeEventListener('click', clickHandler); // return so we can remove the event elsewhere if the action doesn't get called\n}"],"names":[],"version":3,"file":"index.js.map"}